## 动态内存分配

### 原理

![image-20240522155637261](C:\Users\Lianyi\AppData\Roaming\Typora\typora-user-images\image-20240522155637261.png)

### 约束条件

显式分配器必须在一些相当严格的约束条件下工作：

• 处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，分配器不可以假设分配和释放请求的顺序。例如，分配器不能假设所有的分配请求都有相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。

• 立即响应请求。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或者缓冲请求。

• 只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。

・对齐块（对齐要求）。 分配器必须对齐块，使得它们可以保存任何类型的数据对象。

• 不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许 修改或 者移动它了。因此，诸如压缩已分 配块这样的技术是不允许使用的。

### 如何考虑实际

一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题：

• 空闲块组织：我们如何记录空闲块？

・放置：我们如何选择一个合适的空闲块来放置一个新分配的块？

・分割：在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？

• 合并：我们如何处理一个刚刚被释放的块？

![image-20240522160710528](C:\Users\Lianyi\AppData\Roaming\Typora\typora-user-images\image-20240522160710528.png)

“伙伴系统”

回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部。

### linux编译错误解决

这两条命令，就能够得到测试结果了。

　　但是遗憾的是，很多小伙伴像我一样，make成功了，但是输入这两条测试命令的时候显示段错误。

　　**为什么呢**？

　　首先我们了解一下make干了什么。

　　我不太明白，但是打开Makefile这个文件：

![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225214146906-2071322315.png)

　　注意，一开始是没有-m32这个编译参数的。所以你执行make的时候就是编译出64位的可执行程序**mdriver**。

　　然而在mm.c的

![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225215104752-901183526.png)

　　这句话就是**发生段错误的原因**。

　　在32位的程序中，这段代码是没问题的，因为32位程序中的指针显然只有32bit，但是**64位的程序中的指针是有64bit的**。然而后面的(unsigned int)类型的数据，无论是在32位或者是64位的程序，都是32bit也就是4B的。

　　所以，我们rm mdriver，将现有的mdriver删掉，然后再make重新生成新的mdriver。

　　在make之前，首先将上面的CFLAGS加上一个**-m32**

　　然后make

　　但是很遗憾:

![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225215806941-1994257859.png)

　　我们注意到上面的**gcc -Wall -O2 -m32 -o mdriver ............**

　　再看看下面的，显然就是生成的mdriver的之前的各种.o文件还是64bit的。所以，我们执行7次这样的类似操作：

![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225220024314-1835206376.png)

　　注意编译参数加上**-c 即只编译不链接**。

　　然后我们**不make了**。

　　直接**gcc -Wall -O2 -m32 -o mdriver mdriver.o mm.o ........**就可以，完整的代码在上面的图片里有。

　　**最后生成的mdriver是可以用的**！直接

![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225220535539-1663772498.png)　　　　 ![img](https://img2020.cnblogs.com/blog/1861421/202112/1861421-20211225220549980-701846969.png)

　　**成功得到测试结果**！

　　当然，我觉得NB的大佬可以直接对于make相关的文件修改使得make适配64位的机器。当然make本质上就是一个编译链接的脚本，我们手动编译链接也是可以的。　　

### 

![image-20240522224218016](C:\Users\Lianyi\AppData\Roaming\Typora\typora-user-images\image-20240522224218016.png)

在序言块之前放置 20 个空闲链表头指针，分配序言块和结尾块，放好heap_list

![image-20240524002500965](C:\Users\Lianyi\AppData\Roaming\Typora\typora-user-images\image-20240524002500965.png)

由

static void *extend_heap(size_t *words*);   //扩展堆

static void *coalesce(void **bp*);       //合并空闲块

static void *find_fit(size_t *asize*);     //找到匹配的块

static void place(void **bp*, size_t *asize*);  //分割空闲块

static void delete(void **bp*);        //从相应链表中删除块

static void insert(void **bp*);        //在对应链表中插入块

static int search(size_t *size*);       //根据块大小, 找到头节点位置
